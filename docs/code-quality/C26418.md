---
title: C26418 | Microsoft Docs
ms.custom: 
ms.date: 11/15/2017
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: C26418
helpviewer_keywords: C26418
ms.assetid: d2c84a40-8a5d-4018-92c2-6498cdd9b541
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: c3e101758032182adc83d8487bc371cd81d4e552
ms.sourcegitcommit: fb751e41929f031d1a9247bc7c8727312539ad35
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/15/2017
---
# <a name="c26418-novalueorconstrefsharedptr"></a>C26418 NO_VALUE_OR_CONST_REF_SHARED_PTR
"Parametr sdílené ukazatele není zkopírovat nebo přesunout. Použít T * nebo T & místo. "

**Pokyny pro základní C++**:   
R.36: Trvat const shared_ptr<widget>& parametru express, že ho může zachovat počet odkazů na objekt

Pokud sdílené ukazatel parametr se předává hodnotou nebo odkazem na objekt konstantní, očekává se, že funkce bude převzít kontrolu nad jeho cílový objekt životnost bez ovlivnění volajícího. Kód by měl buď zkopírovat nebo přesunout parametr sdílené ukazatele k jinému objektu sdílené ukazatel nebo předat dál jiný kód vyvoláním funkce, které přijímají sdílené ukazatele. Pokud tomu tak není, pak prostý ukazatel nebo odkaz může být v rámci výpočetních procesů.

## <a name="remarks"></a>Poznámky
-  Tato kontrola rozpozná std::shared_pointer a uživatelem definované typy, které by mohly se bude chovat, jako jsou sdílené ukazatele. Následující vlastnosti se očekává pro uživatelem definované sdílené ukazatele:
-  přetížený dereference nebo člen přístup operátory (veřejné a odstranit);
-  kopírovací konstruktor nebo kopírování operátor přiřazení (veřejné a odstranit);
-  veřejné destruktor, což je odstranit ani použita jako výchozí. Prázdný destruktory stále počítají jako uživatelsky definovanou.

## <a name="example"></a>Příklad 
komplikace nepotřebné rozhraní

```cpp
template<class T>
std::string to_string(const std::shared_ptr<T> &e) // C26418, also C26415 SMART_PTR_NOT_NEEDED
{
    return !e ? null_string : e->to_string();
}
```

## <a name="example"></a>Příklad 
nepotřebné rozhraní komplikace – zjednodušená

```cpp
template<class T>
std::string to_string(const T *e)
{
    return !e ? null_string : e->to_string();
}
```
